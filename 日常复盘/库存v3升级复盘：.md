库存v3升级复盘：

1. 库存流水的处理方式：归档 or 分库分表 如何抉择，以及具体如何做

2. 分布式事务的产生、性能

3. returning 语法在扣减库存场景下的使用

4. 上线方案的细化，考虑上线过程中有小流量，导致新旧流量并存的场景，如何兼容

5. 技术设计中，什么是有讨论价值的？应该是从过程推导结果，而非用结果填补过程

   - N层和双层父子模型的选择，这个比较没有价值
   - 价值在单层和双层（1到多）

6. 问题抽象：库存抽象为物理和逻辑

7. 表设计中，ukey 的设计非常重要

   - 个数：
   - 尽量用 int 类型字段，不要用 string 类型

8. 接口的设计，系统内部的实现细节是否需要暴露给上游：比如库存中的父子库存概念

9. 接口必须向前兼容

   - 字段不能修改，只能新增：对修改关闭，对扩展开放
   - 旧有逻辑不能轻易修改：这里指的是同一个动作导致的最后的表现，不应该有变化

10. 设计应该保持逻辑上的一致，比如设计父子库存时，可能当前这个库存并没有逻辑属性，也就还没必要拆分出子库存。但是为了模型上统一的，可以考虑对每一个父库存，都要拆分出对应的子库存。只不过原本没有子库存的父库存，有一个在数量上和其相等的子库存，并且其逻辑属性为默认值。

11. Redis 大 key 的标准，及 大 key 的解决方法

12. 定义常量不要使用 0 作为默认值。gorm 中对于将值修改为 0 并不友好

13. 逻辑删除导致唯一键冲突的问题

14. 库存系统强势则可以要求上下游使用库存系统生成的唯一键，比如 stock_id

15. 变量命名要表意，命名要多思考，不然很容易被人吐槽

16. 设计接口时，表达一个实体的属性尽量组织到一期。比如当前能表达一个库存记录的属性包括：resource_type+resource_id+warehouse_id+start_time+end_time

17. 不要搞大事务

18. 批量操作不要承诺全部成功或全部失败

19. 批量操作要限制数量

20. 接手模块或者系统，要进行修改时，一定要搞清楚上游，具体是怎么调用的，怎么约定的，具体场景是什么。了解好场景才能写出适合的，易用的接口，否则很容易改来改去

21. 以前的代码不要轻易动，哪怕是日志

22. 压测，模拟线上

    ```sql
    select order_id,  count(*) as total from order_product group by order_id order by total desc;
    ```

23. Golang 中同一个文件，可见性高的函数写在前面
24. 循环中报错时，到底是 continue 还是 return err 要格外注意
25. 缓存的 key 尽量封装一下，get 和 set 都要用
26. 测试的边缘 case 考虑下，比如扣成库存只有0，比如最后库存只剩下2，来了一笔3的请求；或者来了一笔2的请求
27. Returning 语法也支持批量
28. 看耗时，不要单单看自己的接口耗时，要看整个链路的耗时
    - 比如当前下单耗时 1400ms，1500ms 是上限，那么改造后的接口理论不能突破这个上限
29. 重要服务，上线需要在 ppe 上验证下，不要嫌麻烦
30. 在缓存某个日期下的库存记录时，使用到了 list 类型。虽然是整存整取，但为什么没有使用 string呢？因为会有大 key 的风险。但 list 类型会有一个问题，就是在更新缓存时（使用LPush）前需要先删除缓存，否则在并发场景下会出现缓存中有多个重复的数据的情况。
31. 使用 golang 的 map 一定要注意并发读写的问题
32. 事务中，如果业务上没有严格的 sql 执行顺序的要求，应该把容易出错的放到前面。这样出错回滚的话，也不用回滚已经执行过的语句，数据库的开销会小，代码性能会高。比如创建库存时，是先创建库存，后创建流水
33. 修改接口时，必须要向前兼容，尤其是结合当前的调用场景，不能加了新逻辑上线之后导致原来的调用方使用不了。比如加一个参数校验，原调用方的请求是否会因为多了这个参数校验而得到与之前不一样的结果呢。原则上是不能的，除非万不得已必须得加，这个时候需要先Push上游一起修改调用参数，成本很高
34. For 循环中，continue 还是 return 需要仔细斟酌
35. 创建常量根据实际使用将其定义在合适的地方，如果仅在当前文件内使用，就定义在当前文件即可
36. 校验过程中最好不要与 DB 交互
37. 命名很重要，需要表意且不能有歧义
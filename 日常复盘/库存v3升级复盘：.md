# 库存系统升级复盘

## 1 前言

过去2个月，自己完成了组内库存系统的升级。主要实现：

### 1.1 完善并建立库存模型。

过去的库存系统完成的功能：

- 将 sku 的库存属性迁移到库存中心，并把 sku 抽象为 resource。使得库存不仅可以表示 sku 的库存，还可以表示优惠券等库存。这里的关键是，对库存来说，它记得是某个资源的库存，具体资源是啥，是由上游决定的。
- 引入库存流水机制，记录操作前后的库存数量，对操作进行留痕，同时也可供业务对账。

本次升级的主要功能点是：

- 进一步对 resource 的属性进行抽象，分为物理属性和逻辑属性。物理属性包括时间和空间，是库存固有的；逻辑属性更多来自业务的划分，比如活动、分销渠道等，并非是库存固有的。
- 依托物理属性和逻辑属性，提出双层父子模型。父库存由物理属性标识，当有逻辑属性引入时，父库存可以根据逻辑属性划分出子库存。

## 1.2 引入预占库存

过去库存系统的数量模型是：

- 只有一个总库存：`sum_count`，其实就是从 sku 表中的 `stock_count` 迁移过来的

- 引入「预占库存」的概念，下单时预占，取消订单时释放，支付时扣减，退款时回滚。主要解决的一个问题是：之前是下单会直接扣减总库存，总库存会实时展现给商家。但用户下单不代表一定能支付成单，有一部分订单会在30分钟内由于未支付而自动取消，此时总库存会回滚。在大促场景下，商家会很关注库存的变化。当发现总库存减的很快时，商家会操作库存，而实际上这部分减掉的库存在30分钟后会被加回来，这就会导致商家误判。

  预占库存如何引入呢？添加 2 个字段：`total_count`，`withholding_count`，分别称作：可用库存，预占库存。具体扣减规则：

  下单 n：总库存不变，可用库存 - n，预占库存 + n；

  支付 n：总库存 - n，可用库存不变，预占库存 -n；

  订单取消：总库存不变，可用库存 + n，预占库存 - n；

  退款：总库存 + n，可用库存 + n

  要求时刻满足：总库存 = 可用库存 + 预占库存

## 1.3 引入累计投放库存

当前数量模型只能记录当前时刻某商品的总库存、可用库存、预占库存。而商家还有希望查看对某商品总共投放了多少库存的需求，`origin_count` 只会被B端的接口影响（追加、减少、覆盖更新库存），C 端的请求不影响 `origin_count`

## 1.4 引入 returning 语法

引入 returning 语法，优化库存扣减的数据库流程，提高写 QPS。具体优化结果：

以上，可以详细查看 《库存设计》的文档

## 2 系统设计相关

### 2.1 库存流水的处理方式：归档 or 分库分表

库存流水归档即可，原因在于：

- 库存流水主要用于业务对账，一般对完账的流水不会再使用
- 分库分表会增加系统的复杂度

### 2.2 商品的库存如何做分库分表

### 2.3 新、旧接口切换时，上线方案的细化

一般情况下，不会出现下游要求上游切换接口的情况。但有时候随着业务的发展，也可能会出现旧接口无论如何都已无法向前兼容新接口了。这时候只能push上游切新接口了。当然还有一种情况，是上游主动需要切换接口。

如果需要切换的接口，只是单独一个接口，那么影响还好。但如果需要切换的是一个完整业务流程的一套接口（比如下单、取消订单、支付、退款），就需要特别考虑上线方案了。因为：

- 旧接口已经承接了线上的流量
- 上线过程一般是小流量->单机房->全流量

这两点可能会使得上线过程中，同一个用户的一个业务流程，不同节点可能会调用新旧接口。比如：下单新接口，支付旧接口。

不配套的接口，可能就会造成预料之外的问题，因此在上线代码中就需要兼容这些场景。

几个原则：

- 谁主动切换，就由谁兼容；
- 自己实在兼容不了的，可以push系统上下游兼容；
- 即使几个系统都做兼容，都无法覆盖所有场景的，可以在上线完成后通过人工修数兜底
- 如果无法把控系统切换过程中存在的风险，就不要切换

### 2.4 技术设计中，什么是有讨论价值的？

技术设计过程中每一个方案的选择，都应该是从各个方案客观的优缺点对比严谨推导出来的结果。而不是事先预设自己要用某个方案，然后从结果去推导，为自己选择某种方案找理由。

比如：

- N层和双层父子模型的选择，这个比较没有价值。因为 N 层明显会比双层复杂很多
- 价值在于单层和双层的选择（1到多）

### 2.5 表设计中，ukey 的设计非常重要

联合索引的字段数量一般不宜过多，最好控制在5个字段以内。当然加字段也不会导致性能降低太多，4个字段组成的联合索引和7个字段组成的联合索引，性能可能差个 5%~10%。该结论并未有数据支持，是 DBA 根据经验值得出的。

用于做联合索引的字段，最好选择 int 类型，尽量不要使用 string、time 等类型。

### 2.6 接口的设计，系统内部的实现细节是否需要暴露给上游

哪些应该暴露，哪些不应该暴露，应该有一些明确的考虑。比如库存中的父子库存概念

### 2.7 接口必须向前兼容

- 字段不能修改，只能新增：对修改关闭，对扩展开放
- 旧有逻辑不能轻易修改：这里指的是同一个动作导致的最后的表现，不应该有变化

### 2.8 好的设计应该是简单而优美的

- 好的设计应该是逻辑是应该是优美的，一致的，自洽的。比如设计父子库存时，可能当前这个库存并没有逻辑属性，也就还没必要拆分出子库存。但是为了模型上统一的，可以考虑对每一个父库存，都要拆分出对应的子库存。只不过原本没有子库存的父库存，有一个在数量上和其相等的子库存，并且其逻辑属性为默认值。
- 好的设计应该是简单的。比如由于排班存在删除又新建的场景，这就会出现逻辑删除场景下唯一索引重复的问题。之前的设计是采用修改状态的方式，这会导致在创建库存时，需要区分哪些库存记录是需要新创建的，哪些是需要更新的，会导致接口的逻辑非常复杂。

当写代码时，如果发现代码写的非常复杂，并且这种复杂并不是业务逻辑上的复杂，而是由技术设计带来的。那么就需要反思是不是技术设计有问题，是不是有更好的技术设计方案。

### 2.9 缓存大 key

大 key 的标准及解法

库存中如何产生的大 key？

单条记录大约 0.25KB，一次最多可查 960 条记录，即以 string 存储的话，一次需要存储 250KB。已经远超大 key 标准。

如何拆解？

- 业务上，优化交互。之前前端是一次请求2个月的排班库存记录，因此需要一次返回 960 条记录。但实际上可以通过 2 次交互完成。第一次返回每日库存的统计值，返回2个月的。这样虽然还是一次需要返回2个月的数据，但是单条数据的大小远小于0.25KB。第二次返回单日的库存记录详情，具体对应用户点击日库存详情的操作。这样单日的库存记录一般不超过 16 条
- 技术上，换不同的 value 类型。但即使只有 16 条，仍然有 4KB 的大小，即仍然很接近大 key。这时候可以选用 redis 的 list 类型



1. 定义常量不要使用 0 作为默认值。gorm 中对于将值修改为 0 并不友好

2. 逻辑删除导致唯一键冲突的问题

3. 库存系统强势则可以要求上下游使用库存系统生成的唯一键，比如 stock_id

4. 变量命名要表意，命名要多思考，不然很容易被人吐槽

5. 设计接口时，表达一个实体的属性尽量组织到一期。比如当前能表达一个库存记录的属性包括：resource_type+resource_id+warehouse_id+start_time+end_time

6. 不要搞大事务

7. 批量操作不要承诺全部成功或全部失败

8. 批量操作要限制数量

9. 接手模块或者系统，要进行修改时，一定要搞清楚上游，具体是怎么调用的，怎么约定的，具体场景是什么。了解好场景才能写出适合的，易用的接口，否则很容易改来改去

10. 以前的代码不要轻易动，哪怕是日志

11. 压测，模拟线上

    ```sql
    select order_id,  count(*) as total from order_product group by order_id order by total desc;
    ```

12. Golang 中同一个文件，可见性高的函数写在前面

13. 循环中报错时，到底是 continue 还是 return err 要格外注意

14. 缓存的 key 尽量封装一下，get 和 set 都要用

15. 测试的边缘 case 考虑下，比如扣成库存只有0，比如最后库存只剩下2，来了一笔3的请求；或者来了一笔2的请求

16. Returning 语法也支持批量

17. 看耗时，不要单单看自己的接口耗时，要看整个链路的耗时

    - 比如当前下单耗时 1400ms，1500ms 是上限，那么改造后的接口理论不能突破这个上限

18. 重要服务，上线需要在 ppe 上验证下，不要嫌麻烦

19. 在缓存某个日期下的库存记录时，使用到了 list 类型。虽然是整存整取，但为什么没有使用 string呢？因为会有大 key 的风险。但 list 类型会有一个问题，就是在更新缓存时（使用LPush）前需要先删除缓存，否则在并发场景下会出现缓存中有多个重复的数据的情况。

20. 使用 golang 的 map 一定要注意并发读写的问题

21. 事务中，如果业务上没有严格的 sql 执行顺序的要求，应该把容易出错的放到前面。这样出错回滚的话，也不用回滚已经执行过的语句，数据库的开销会小，代码性能会高。比如创建库存时，是先创建库存，后创建流水

22. 修改接口时，必须要向前兼容，尤其是结合当前的调用场景，不能加了新逻辑上线之后导致原来的调用方使用不了。比如加一个参数校验，原调用方的请求是否会因为多了这个参数校验而得到与之前不一样的结果呢。原则上是不能的，除非万不得已必须得加，这个时候需要先Push上游一起修改调用参数，成本很高

23. For 循环中，continue 还是 return 需要仔细斟酌

24. 创建常量根据实际使用将其定义在合适的地方，如果仅在当前文件内使用，就定义在当前文件即可

25. 校验过程中最好不要与 DB 交互

26. 命名很重要，需要表意且不能有歧义